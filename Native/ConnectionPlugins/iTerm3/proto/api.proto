syntax = "proto2";
option objc_class_prefix = "ITM";
package iterm2;

// A note on session IDs:
// In requests, session IDs may take one of three values;
// 1. A unique ID as returned in ListSessionsResponse
// 2. The special value "all", which applies to all sessions. This is sometimes not accepted. See
//    comments in the request message for details.
// 3. The special value "active", which applies to the session with keyboard focus.

// All requests are wrapped in this message. This encoded message is the entirety of the payload
// of messages sent over WebSocket from client to iTerm2.
message ClientOriginatedMessage {
  optional int64 id = 1;

  oneof submessage {
    GetBufferRequest get_buffer_request = 100;
    GetPromptRequest get_prompt_request = 101;
    TransactionRequest transaction_request = 102;
    NotificationRequest notification_request = 103;
    RegisterToolRequest register_tool_request = 104;
    SetProfilePropertyRequest set_profile_property_request = 105;
    ListSessionsRequest list_sessions_request = 106;
    SendTextRequest send_text_request = 107;
    CreateTabRequest create_tab_request = 108;
    SplitPaneRequest split_pane_request = 109;
    GetProfilePropertyRequest get_profile_property_request = 110;
    SetPropertyRequest set_property_request = 111;
    GetPropertyRequest get_property_request = 112;
    InjectRequest inject_request = 113;
    ActivateRequest activate_request = 114;
    VariableRequest variable_request = 115;
    SavedArrangementRequest saved_arrangement_request = 116;
    FocusRequest focus_request = 117;
  }
}

// All responses are wrapped in this message. This encoded message is the entirety of the payload
// of messages sent over WebSocket from iTerm2 to client.
message ServerOriginatedMessage {
  optional int64 id = 1;

  // Responses to ClientOriginatedMessages of the corresponding type
  oneof submessage {
    string error = 2;  // Set if request was malformed

    GetBufferResponse get_buffer_response = 100;
    GetPromptResponse get_prompt_response = 101;
    TransactionResponse transaction_response = 102;
    NotificationResponse notification_response = 103;
    RegisterToolResponse register_tool_response = 104;
    SetProfilePropertyResponse set_profile_property_response = 105;
    ListSessionsResponse list_sessions_response = 106;
    SendTextResponse send_text_response = 107;
    CreateTabResponse create_tab_response = 108;
    SplitPaneResponse split_pane_response = 109;
    GetProfilePropertyResponse get_profile_property_response = 110;
    SetPropertyResponse set_property_response = 111;
    GetPropertyResponse get_property_response = 112;
    InjectResponse inject_response = 113;
    ActivateResponse activate_response = 114;
    VariableResponse variable_response = 115;
    SavedArrangementResponse saved_arrangement_response = 116;
    FocusResponse focus_response = 117;

    // This is the only response that is sent spontaneously. The 'id' field will not be set.
    Notification notification = 1000;
  }
}

message FocusRequest {
}

message FocusResponse {
  // A collection of notifications that completely describe the state of every tab and window and
  // the application itself.
  repeated FocusChangedNotification notifications = 1;
}

message SavedArrangementRequest {
  optional string name = 1;
  enum Action {
    // Restore an existing arrangement with the given name
    RESTORE = 0;

    // Save windows to a new arrangment with the given name
    SAVE = 1;
  }
  optional Action action = 2;

  // If given and the action is SAVE then only the tabs in the identified window are saved.
  // If given and the action is RESTORE then the arrangement will be restored as tabs in the identified window.
  optional string window_id = 3;
}

message SavedArrangementResponse {
  enum Status {
    OK = 0;
    ARRANGEMENT_NOT_FOUND = 1;  // Tried to restore, but name doesn't exist
    WINDOW_NOT_FOUND = 2;  // Bad window ID provided
    REQUEST_MALFORMED = 3;
  }
  optional Status status = 1;
}

message VariableRequest {
  optional string session_id = 1;  // "all" is allowed only if no gets (only sets allowed)

  message Set {
    optional string name = 1;
    optional string value = 2;
  }
  repeated Set set = 2;
  repeated string get = 3;  // Set to special value "*" to get all in newline-delimited list.
}

message VariableResponse {
  enum Status {
    OK = 0;
    SESSION_NOT_FOUND = 1;
    INVALID_NAME = 2;  // Names you set must begin with "user."
  }
  optional Status status = 1;
  repeated string values = 2;  // 1:1 with get field in request. Empty and undefined are the same.
}

message ActivateRequest {
  // To activate the app without changing anything else omit the identifier.
  oneof identifier {
    string window_id = 1;
    string tab_id = 2;
    string session_id = 3;
  }
  optional bool order_window_front = 4;

  // This may be enabled if tab_id or session_id is set.
  optional bool select_tab = 5;

  // This may be enabled if session_id is set.
  optional bool select_session = 6;

  // Activate the app?
  message App {
    optional bool raise_all_windows = 1;
    optional bool ignoring_other_apps = 2;
  }
  optional App activate_app = 7;
}

message ActivateResponse {
  enum Status {
    OK = 0;
    BAD_IDENTIFIER = 1;
    INVALID_OPTION = 2;
  }
  optional Status status = 1;
}

// Injects bytes as input to the terminal, as though the running program had produced them.
message InjectRequest {
  repeated string session_id = 1;
  optional bytes data = 2;
}

message InjectResponse {
  enum Status {
    OK = 0;
    SESSION_NOT_FOUND = 1;
  }
  // One status per session_id in the request
  repeated Status status = 1;
}

message GetPropertyRequest {
  // Eventually you'll be able to request properties on other things besides
  // window_id. The kind of ID that's set determines the kind of object you're
  // querying.
  oneof identifier {
    string window_id = 1;
  }
  optional string name = 2;
}

message GetPropertyResponse {
  enum Status {
    OK = 0;
    UNRECOGNIZED_NAME = 1;
    INVALID_TARGET = 2;
  }
  // Name           Example value
  // -------------  ---------------
  // frame          { "origin": { "x": 0, "y": 0 }, "size": { "width": 1024, "height": 768 }}
  // fullscreen     true, false
  optional Status status = 1;
  optional string json_value = 2;
}

message SetPropertyRequest {
  // Eventually you'll be able to set properties on other things besides
  // window_id. The kind of ID that's set determines the kind of object you're
  // updating.
  oneof identifier {
    string window_id = 1;
  }
  // Name           Example JSON
  // -------------  ---------------
  // frame          { "origin": { "x": 0, "y": 0 }, "size": { "width": 1024, "height": 768 }}
  // fullscreen     true, false
  optional string name = 3;
  optional string json_value = 4;
}

message SetPropertyResponse {
  enum Status {
    OK = 0;
    UNRECOGNIZED_NAME = 1;
    INVALID_VALUE = 2;  // e.g., bad JSON value
    INVALID_TARGET = 3;  // e.g., bogus window_id
  }
  optional Status status = 1;
}

// Registers a toolbelt tool that displays a webview with a URL of your choice.
message RegisterToolRequest {
  // This name is displayed to the user.
  optional string name = 1;

  // The tool's identifier should be unique. Prefix it with your app bundle. For example:
  // com.example.mytool
  optional string identifier = 2;

  enum ToolType {
    WEB_VIEW_TOOL = 1;
  }

  // The first time a tool is registered iTerm2 automatically adds it to the
  // set of visible tools. To show it on subsequent re-registrations, set this
  // to true. If the toolbelt itself is hidden, it will not be opened.
  optional bool reveal_if_already_registered = 5 [default = false];

  optional ToolType tool_type = 3 [default = WEB_VIEW_TOOL];

  // For web view tools: The URL loaded at startup
  optional string URL = 4;
}

message RegisterToolResponse {
  enum Status {
    OK = 0;
    REQUEST_MALFORMED = 1;
    PERMISSION_DENIED = 2;
  }

  optional Status status = 1;
}

enum NotificationType {
  // Notifications that use the `session` parameter.
  NOTIFY_ON_KEYSTROKE = 1;
  NOTIFY_ON_SCREEN_UPDATE = 2;
  NOTIFY_ON_PROMPT = 3;
  NOTIFY_ON_LOCATION_CHANGE = 4;
  NOTIFY_ON_CUSTOM_ESCAPE_SEQUENCE = 5;

  // Notifications that ignore the `session` parameter.
  NOTIFY_ON_NEW_SESSION = 6;
  NOTIFY_ON_TERMINATE_SESSION = 7;
  NOTIFY_ON_LAYOUT_CHANGE = 8;
  NOTIFY_ON_FOCUS_CHANGE = 9;
}

message NotificationRequest {
  // See documentation on session IDs. NOTIFY_ON_NEW_SESSION, NOTIFY_ON_TERMINATE_SESSION, and
  // NOTIFY_ON_LAYOUT_CHANGE do not use the session ID and are posted on all such events.
  optional string session = 1;

  // Set to true to subscribe, false to unsubscribe.
  optional bool subscribe = 2;

  // When to be notified (or notification to unsubscribe from)
  optional NotificationType notification_type = 3;
}

message NotificationResponse {
  enum Status {
    OK = 0;
    SESSION_NOT_FOUND = 1;
    REQUEST_MALFORMED = 2;
    NOT_SUBSCRIBED = 3;
    ALREADY_SUBSCRIBED = 4;
  }
  optional Status status = 1;
}

message Notification {
  optional KeystrokeNotification keystroke_notification = 1;
  optional ScreenUpdateNotification screen_update_notification = 2;
  optional PromptNotification prompt_notification = 3;
  optional LocationChangeNotification location_change_notification = 4;
  optional CustomEscapeSequenceNotification custom_escape_sequence_notification = 5;
  optional NewSessionNotification new_session_notification = 6;
  optional TerminateSessionNotification terminate_session_notification = 7;
  optional LayoutChangedNotification layout_changed_notification = 8;
  optional FocusChangedNotification focus_changed_notification = 9;
}

message KeystrokeNotification {
  optional string characters = 1;
  optional string charactersIgnoringModifiers = 2;
  enum Modifiers {
    CONTROL = 1;
    OPTION = 2;
    COMMAND = 3;
    SHIFT = 4;
    FUNCTION = 5;
    NUMPAD = 6;
  }
  repeated Modifiers modifiers = 3;
  optional int32 keyCode = 4;
  optional string session = 5;
}

message ScreenUpdateNotification {
  optional string session = 1;
}

message PromptNotification {
  optional string session = 1;
}

message LocationChangeNotification {
  optional string host_name = 1;
  optional string user_name = 2;
  optional string directory = 3;
  optional string session = 4;
}

// OSC 1337 ; Custom=id=<identity>:<payload> ST
message CustomEscapeSequenceNotification {
  optional string session = 1;
  optional string sender_identity = 2;
  optional string payload = 3;
}

// Sent when a new session is created or a closure is undone.
message NewSessionNotification {
  optional string uniqueIdentifier = 1;
}

// Note this is sent when the app becomes/resigns active, the key window changes, the selected tab
// of a window changes, or the active pane of a tab changes. Note that you may receive duplicate
// notifications at times. Ignore those that do not signify a change.
message FocusChangedNotification {
  message Window {
    enum WindowStatus {
      // `window_id` became key
      TERMINAL_WINDOW_BECAME_KEY = 0;

      // `window_id` is not key, but is the current terminal window. Some other non-terminal window is key.
      TERMINAL_WINDOW_IS_CURRENT = 1;

      // `window_id` is no longer key.
      TERMINAL_WINDOW_RESIGNED_KEY = 2;
    }
    // Describes how to interpret window_id.
    optional WindowStatus window_status = 1;

    // The affected window_id
    optional string window_id = 2;
  }
  oneof event {
    // true: application became active. false: application resigned active.
    bool application_active = 1;

    // If set, gives info about a change to window focus.
    Window window = 2;

    // If set, selected tab changed to the one identified herein.
    string selected_tab = 3;

    // If set, the given session became active in its tab.
    string session = 4;
  }
}

// Note this is sent when a session is removed from the screen but its closure remains undoable.
message TerminateSessionNotification {
  optional string uniqueIdentifier = 1;
}

message LayoutChangedNotification {
  optional ListSessionsResponse list_sessions_response = 1;
}

// Requests the contents of a range of lines.
message GetBufferRequest {
  // See documentation on session IDs. "all" not accepted.
  optional string session = 1;

  // Which lines to return?
  optional LineRange line_range = 2;
}

// Contains the contents of a range of lines.
message GetBufferResponse {
  enum Status {
    OK = 0;
    SESSION_NOT_FOUND = 1;
    INVALID_LINE_RANGE = 2;
    REQUEST_MALFORMED = 3;
  }

  optional Status status = 1 [default = OK];

  // Which lines were returned
  optional Range range = 2;

  // Those lines' contents.
  repeated LineContents contents = 3;

  optional Coord cursor = 4;

  // The number of lines (including lines lost from the head of scrollback history) that precede
  // the screen. Subtract this from cursor.y to get the cursor's position on the screen when it
  // is scrolled to the bottom.
  optional int64 num_lines_above_screen = 5;
}

// Requests metadata about the current shell prompt.
message GetPromptRequest {
  // See documentation on session IDs. "all" not accepted.
  optional string session = 1;
}

// Reponds with metadata about the current shell prompt, if possible.
message GetPromptResponse {
  enum Status {
    OK = 0;
    SESSION_NOT_FOUND = 1;
    REQUEST_MALFORMED = 2;
    PROMPT_UNAVAILABLE = 3;
  }

  optional Status status = 1 [default = OK];

  optional CoordRange prompt_range = 2;
  optional CoordRange command_range = 3;
  optional CoordRange output_range = 4;

  optional string working_directory = 5;
  optional string command = 6;
}

message GetProfilePropertyRequest {
  // See documentation on session IDs
  optional string session = 1;

  // If not set, all properties will be returned
  repeated string keys = 2;
}

message GetProfilePropertyResponse {
  enum Status {
    OK = 0;
    SESSION_NOT_FOUND = 1;
    REQUEST_MALFORMED = 2;
    ERROR = 3;
  }

  optional Status status = 1 [default = OK];

  message Property {
    optional string key = 1;
    optional string json_value = 2;
  }
  repeated Property properties = 3;
}

// Sets a value in a session's copy of the profile without modifying the underlying profile.
message SetProfilePropertyRequest {
  // See documentation on session IDs
  optional string session = 1;

  // The following keys are allowed. This table also gives the type that's expected in json_value:
  // Name                                            String
  // Badge Text                                      String
  // Answerback String                               String
  // Foreground Color                                Color Dictionary
  // Background Color                                Color Dictionary
  // Bold Color                                      Color Dictionary
  // Link Color                                      Color Dictionary
  // Selection Color                                 Color Dictionary
  // Selected Text Color                             Color Dictionary
  // Cursor Color                                    Color Dictionary
  // Cursor Text Color                               Color Dictionary
  // Ansi 0 Color                                    Color Dictionary
  // Ansi 1 Color                                    Color Dictionary
  // Ansi 2 Color                                    Color Dictionary
  // Ansi 3 Color                                    Color Dictionary
  // Ansi 4 Color                                    Color Dictionary
  // Ansi 5 Color                                    Color Dictionary
  // Ansi 6 Color                                    Color Dictionary
  // Ansi 7 Color                                    Color Dictionary
  // Ansi 8 Color                                    Color Dictionary
  // Ansi 9 Color                                    Color Dictionary
  // Ansi 10 Color                                   Color Dictionary
  // Ansi 11 Color                                   Color Dictionary
  // Ansi 12 Color                                   Color Dictionary
  // Ansi 13 Color                                   Color Dictionary
  // Ansi 14 Color                                   Color Dictionary
  // Ansi 15 Color                                   Color Dictionary
  // Smart Cursor Color                              Color Dictionary
  // Tab Color                                       Color Dictionary
  // Underline Color                                 Color Dictionary
  // Cursor Guide Color                              Color Dictionary
  // Badge Color                                     Color Dictionary
  // Use Cursor Guide                                Number (boolean)
  // Use Tab Color                                   Number (boolean)
  // Use Underline Color                             Number (boolean)
  // Smart Cursor Color                              Number (boolean)
  // Minimum Contrast                                Number (0-1)
  // Cursor Boost                                    Number (0-1)
  // Cursor Type                                     Number (0=underline, 1=vertical, 2=box)
  // Blinking Cursor                                 Number (boolean)
  // Use Bold Font                                   Number (boolean)
  // Thin Strokes                                    Number (0=no, 1=retina only, 2=always)
  // ASCII Ligatures                                 Number (boolean)
  // Non-ASCII Ligatures                             Number (boolean)
  // Use Bright Bold                                 Number (boolean)
  // Blink Allowed                                   Number (boolean)
  // Use Italic Font                                 Number (boolean)
  // Ambiguous Double Width                          Number (boolean)
  // Unicode Normalization                           Number (0=none, 1=nfc, 2=nfd, 3=hfs+)
  // Horizontal Spacing                              Number (floating point)
  // Vertical Spacing                                Number (floating point)
  // Use Non-ASCII Font                              Number (boolean)
  // Transparency                                    Number (0-1)
  // Blur                                            Number (boolean)
  // Blur Radius                                     Number (0.1-30)
  // Background Image Is Tiled                       Number (boolean)
  // Blend                                           Number (0-1)
  // Sync Title                                      Number (boolean)
  // Disable Window Resizing                         Number (boolean)
  // Only The Default BG Color Uses Transparency     Number (boolean)
  // ASCII Anti Aliased                              Number (boolean)
  // Non-ASCII Anti Aliased                          Number (boolean)
  // Scrollback Lines                                Number (integer)
  // Unlimited Scrollback                            Number (boolean)
  // Scrollback With Status Bar                      Number (boolean)
  // Scrollback in Alternate Screen                  Number (boolean)
  // Character Encoding                              Number (integer, 4=UTF-8)
  // Mouse Reporting                                 Number (boolean)
  // Mouse Reporting allow mouse wheel               Number (boolean)
  // Unicode Version                                 Number (integer, 8 or 9)
  // Allow Title Reporting                           Number (boolean)
  // Allow Title Setting                             Number (boolean)
  // Disable Printing                                Number (boolean)
  // Disable Smcup Rmcup                             Number (boolean)
  // Silence Bell                                    Number (boolean)
  // BM Growl                                        Number (boolean)
  // Send Bell Alert                                 Number (boolean)
  // Send Idle Alert                                 Number (boolean)
  // Send New Output Alert                           Number (boolean)
  // Send Session Ended Alert                        Number (boolean)
  // Send Terminal Generated Alerts                  Number (boolean)
  // Flashing Bell                                   Number (boolean)
  // Visual Bell                                     Number (boolean)
  // Close Sessions On End                           Number (boolean)
  // Prompt Before Closing 2                         Number (boolean)
  // Session Close Undo Timeout                      Number (floating point, number of seconds)
  // Reduce Flicker                                  Number (boolean)
  // Send Code When Idle                             Number (boolean)
  // Idle Code                                       Number (integer, 0-255)
  // Idle Period                                     Number (floating point, number of seconds)
  // Option Key Sends                                Number (0=normal, 1=meta, 2=+esc)
  // Right Option Key Sends                          Number (0=normal, 1=meta, 2=+esc)
  // Application Keypad Allowed                      Number (boolean)
  // Place Prompt at First Column                    Number (boolean)
  // Show Mark Indicators                            Number (boolean)
  //
  // Color dictionaries have these mandatory keys taking numeric values between 0 and 1:
  //   Red Component, Green Component, Blue Component
  // And an optional key with a value in 0 to 1:
  //   Alpha Component
  //
  optional string key = 2;

  // Does not need to be a dictionary. Here are examples of JSON protos having JSON values:
  // Numeric example:
  //   "json_value": "0.5"
  // String example:
  //   "json_value": "\"Hello world\""
  // Color example:
  //   "json_value": "{\"Red Component\": 1, \"Green Component\": 0, \"Blue Component\": 0, \"Alpha Component\": 1}"
  optional string json_value = 3;
}

message SetProfilePropertyResponse {
  enum Status {
    OK = 0;
    SESSION_NOT_FOUND = 1;
    REQUEST_MALFORMED = 2;
  }

  optional Status status = 1 [default = OK];
}

message TransactionRequest {
  // Set to true to begin a new transaction or false to end the current
  // transaction. The app's main loop will not advance while in a
  // transaction. This effectively freezes time. Keep transactions short.
  optional bool begin = 1;
}

message TransactionResponse {
  enum Status {
    OK = 0;
    NO_TRANSACTION = 1;
    ALREADY_IN_TRANSACTION = 2;
  }
  optional Status status = 1 [default = OK];
}

// Describes a range of lines.
message LineRange {
  // Only one of these fields should be set:
  // ---------------------------------------
  // Return just the current contents of the screen.
  optional bool screen_contents_only = 1;

  // Return the last `trailing lines` of the buffer, which could go back into
  // scrollback history.
  optional int32 trailing_lines = 2;
}

// Describes a range of values.
message Range {
  optional int64 location = 1;
  optional int64 length = 2;
}

// Describes a range of cells.
// |..xxxxx|
// |xxxx...|
// In the example above, the range of x's is: {start: {x:2, y:0}, end: {x:4, y:1}}
// The end coordinate is the first cell *after* the end of the range described (so an empty range
// has start == end)
message CoordRange {
  optional Coord start = 1;
  optional Coord end = 2;
}

// Describes a cell's location.
message Coord {
  optional int32 x = 1;
  // y=0 describes the first line. When the scrollback buffer is full and history is lost, the first
  // lines become unavailable, but the numbering is stable (so the Nth line is always the Nth line,
  // even if it's not the Nth *visible* line).
  optional int64 y = 2;
}

// Describes the content of a line.
message LineContents {
  optional string text = 1;

  // Some cells do not contain one code point. Use this to map code points in
  // `text` to a screen position. If the line has no uninitialized cells at its end, then the
  // sum of `repeats` equals the width of the display.
  //
  // For example, consider a line of text that appears on your display like:
  //   xyz compañía
  //
  // The corresponding value of `text` would be:
  //   xyzcompan~i'a
  // Note: ~ and ' are combining marks, but are shown uncombined for illustrative purposes.
  //
  // Each code point in "xyz" as well as each of the non-accented letters in compañía takes one
  // cell.
  //
  // The blank following 'z' is an uninitialized cell that has no code points,
  // so the z and the c in `text` are adjacent. It's unusual for these to occur in the middle
  // of a line, but it is possible.
  //
  // The ñ is composed of the letter n and a combining tilde (U+0303) (indicated in our example
  // as ~), while í is composed of the leter i and a combining acute accent (U+0301) (indicated in
  // our example as ').
  //
  // To map code points in `text` to screen positions, `code_points_per_cell`
  // provides the number of code points in each cell. In our example you would
  // get:
  //
  //   num_code_points=1, repeats=3     // x, y, z
  //   num_code_points=0, repeats=1     // uninitialized cell
  //   num_code_points=1, repeats=5     // c, o, m, p, a
  //   num_code_points=2, repeats=2     // n + combining tilde, i + combining acute accent
  //   num_code_points=1, repeats=1     // a
  //
  // Lines usually end with a series of uninitialized cells. These are not included.
  //
  // Here is psuedocode to interpret code_points_per_cell:
  //
  //   text_index_to_screen_coord = {}
  //   screen_coord_to_text_index = {}
  //   text_index = 0
  //   screen_coord = 0
  //   for cpps in code_points_per_cell:
  //     repeat cpps.repeats times:
  //       text_index_to_screen_coord[text_index] = screen_coord
  //       screen_coord_to_text_index[screen_coord] = text_index
  //       text_index += cpps.num_code_points
  //       screen_coord += 1
  //
  // Cells with images are omitted.
  repeated CodePointsPerCell code_points_per_cell = 2;

  // How does this line end?
  enum Continuation {
    // This line is not wrapped.
    CONTINUATION_HARD_EOL = 1;

    // The next line is a continuation of this line.
    CONTINUATION_SOFT_EOL = 2;
  }
  optional Continuation continuation = 3 [default = CONTINUATION_HARD_EOL];
}

message CodePointsPerCell {
  // Number of code points per cell
  optional int32 num_code_points = 1 [default = 1];

  // Number of adjacent cells with this number of code points (always one or more).
  optional int32 repeats = 2;
}

message ListSessionsRequest {
}

message SendTextRequest {
  // See documentation on session IDs
  optional string session = 1;

  // The text to send. As usual for proto buffers, this should be UTF-8
  // encoded. It will be converted to the session's encoding before being sent.
  optional string text = 2;
}

message SendTextResponse {
  enum Status {
    OK = 0;
    SESSION_NOT_FOUND = 1;
  }

  optional Status status = 1;
}

message Size {
  optional int32 width = 1;
  optional int32 height = 2;
}

message Point {
  optional int32 x = 1;
  optional int32 y = 2;
}

message Frame {
  optional Point origin = 1;
  optional Size size = 2;
}

message ListSessionsResponse {
  message Window {
    repeated Tab tabs = 1;
    optional string window_id = 2;
    optional Frame frame = 3;
  }
  message Tab {
    optional SplitTreeNode root = 3;
    optional string tab_id = 2;
  }
  message SplitTreeNode {
    optional bool vertical = 1;  // Direction of split pane divider
    repeated SplitTreeLink links = 2;  // Links to children

    message SplitTreeLink {
      oneof child {
        Session session = 1;
        SplitTreeNode node = 2;
      }
      message Session {
          optional string unique_identifier = 1;
          optional Frame frame = 2;
          optional Size grid_size = 3;
          optional string title = 4;
      }
    }
  }
  repeated Window windows = 1;
}

message CreateTabRequest {
  // Leave unset to use the default profile.
  optional string profile_name = 1;

  // Leave unset to create the tab in a new window.
  optional string window_id = 2;

  // Valid to set only if window_id is set. Gives the desired index of the new tab.
  optional uint32 tab_index = 3;

  // If not set, the profile's command will be used.
  optional string command = 4;
}

message CreateTabResponse {
  enum Status {
    OK = 0;
    INVALID_PROFILE_NAME = 1;
    INVALID_WINDOW_ID = 2;
    // The tab is still created, just not with the desired index.
    INVALID_TAB_INDEX = 3;
    // A $$VAR$$ substitution was not provided by the user.
    MISSING_SUBSTITUTION = 4;
  }
  optional Status status = 1;
  optional string window_id = 2;
  optional int32 tab_id = 3;
  optional string session_id = 4;
}

message SplitPaneRequest {
  // See documentation on session IDs
  optional string session = 1;

  enum SplitDirection {
    VERTICAL = 0;
    HORIZONTAL = 1;
  }
  optional SplitDirection split_direction = 2;

  // If true, new session is above/left of the session being split. Otherwise, it goes below/right.
  optional bool before = 3 [default=false];

  // Leave unset to use the default profile.
  optional string profile_name = 4;
}

message SplitPaneResponse {
  enum Status {
    OK = 0;
    SESSION_NOT_FOUND = 1;
    INVALID_PROFILE_NAME = 2;
    // This can happen if the session to be split is too small. If splitting multiple sessions and
    // one or more cannot be split, the status will be set to CANNOT_SPLIT, even if some did succeed
    // (in which case there will be one or more session_id's).
    CANNOT_SPLIT = 3;
  }
  optional Status status = 1;

  // TODO(gln): this will not be set for tmux integration because the split happens only if/when the
  // tmux server acts on the request.
  // See documentation on session IDs.
  // If more than one session was split, there will be multiple session_id's.
  repeated string session_id = 2;
}
