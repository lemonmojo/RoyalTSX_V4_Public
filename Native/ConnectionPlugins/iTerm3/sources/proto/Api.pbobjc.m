// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Api.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - ITMApiRoot

@implementation ITMApiRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ITMApiRoot_FileDescriptor

static GPBFileDescriptor *ITMApiRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"iterm2"
                                                 objcPrefix:@"ITM"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum ITMNotificationType

GPBEnumDescriptor *ITMNotificationType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "NotifyOnKeystroke\000NotifyOnScreenUpdate\000N"
        "otifyOnPrompt\000NotifyOnLocationChange\000Not"
        "ifyOnCustomEscapeSequence\000NotifyOnNewSes"
        "sion\000NotifyOnTerminateSession\000NotifyOnLa"
        "youtChange\000NotifyOnFocusChange\000";
    static const int32_t values[] = {
        ITMNotificationType_NotifyOnKeystroke,
        ITMNotificationType_NotifyOnScreenUpdate,
        ITMNotificationType_NotifyOnPrompt,
        ITMNotificationType_NotifyOnLocationChange,
        ITMNotificationType_NotifyOnCustomEscapeSequence,
        ITMNotificationType_NotifyOnNewSession,
        ITMNotificationType_NotifyOnTerminateSession,
        ITMNotificationType_NotifyOnLayoutChange,
        ITMNotificationType_NotifyOnFocusChange,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMNotificationType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMNotificationType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMNotificationType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMNotificationType_NotifyOnKeystroke:
    case ITMNotificationType_NotifyOnScreenUpdate:
    case ITMNotificationType_NotifyOnPrompt:
    case ITMNotificationType_NotifyOnLocationChange:
    case ITMNotificationType_NotifyOnCustomEscapeSequence:
    case ITMNotificationType_NotifyOnNewSession:
    case ITMNotificationType_NotifyOnTerminateSession:
    case ITMNotificationType_NotifyOnLayoutChange:
    case ITMNotificationType_NotifyOnFocusChange:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMClientOriginatedMessage

@implementation ITMClientOriginatedMessage

@dynamic submessageOneOfCase;
@dynamic hasId_p, id_p;
@dynamic getBufferRequest;
@dynamic getPromptRequest;
@dynamic transactionRequest;
@dynamic notificationRequest;
@dynamic registerToolRequest;
@dynamic setProfilePropertyRequest;
@dynamic listSessionsRequest;
@dynamic sendTextRequest;
@dynamic createTabRequest;
@dynamic splitPaneRequest;
@dynamic getProfilePropertyRequest;
@dynamic setPropertyRequest;
@dynamic getPropertyRequest;
@dynamic injectRequest;
@dynamic activateRequest;
@dynamic variableRequest;
@dynamic savedArrangementRequest;
@dynamic focusRequest;

typedef struct ITMClientOriginatedMessage__storage_ {
  uint32_t _has_storage_[2];
  ITMGetBufferRequest *getBufferRequest;
  ITMGetPromptRequest *getPromptRequest;
  ITMTransactionRequest *transactionRequest;
  ITMNotificationRequest *notificationRequest;
  ITMRegisterToolRequest *registerToolRequest;
  ITMSetProfilePropertyRequest *setProfilePropertyRequest;
  ITMListSessionsRequest *listSessionsRequest;
  ITMSendTextRequest *sendTextRequest;
  ITMCreateTabRequest *createTabRequest;
  ITMSplitPaneRequest *splitPaneRequest;
  ITMGetProfilePropertyRequest *getProfilePropertyRequest;
  ITMSetPropertyRequest *setPropertyRequest;
  ITMGetPropertyRequest *getPropertyRequest;
  ITMInjectRequest *injectRequest;
  ITMActivateRequest *activateRequest;
  ITMVariableRequest *variableRequest;
  ITMSavedArrangementRequest *savedArrangementRequest;
  ITMFocusRequest *focusRequest;
  int64_t id_p;
} ITMClientOriginatedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ITMClientOriginatedMessage_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "getBufferRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetBufferRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_GetBufferRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, getBufferRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getPromptRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetPromptRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_GetPromptRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, getPromptRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMTransactionRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_TransactionRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, transactionRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "notificationRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMNotificationRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_NotificationRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, notificationRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "registerToolRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMRegisterToolRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_RegisterToolRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, registerToolRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setProfilePropertyRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSetProfilePropertyRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_SetProfilePropertyRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, setProfilePropertyRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listSessionsRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListSessionsRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_ListSessionsRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, listSessionsRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sendTextRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSendTextRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_SendTextRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, sendTextRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createTabRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCreateTabRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_CreateTabRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, createTabRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "splitPaneRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSplitPaneRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_SplitPaneRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, splitPaneRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getProfilePropertyRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetProfilePropertyRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_GetProfilePropertyRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, getProfilePropertyRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setPropertyRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSetPropertyRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_SetPropertyRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, setPropertyRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getPropertyRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetPropertyRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_GetPropertyRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, getPropertyRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "injectRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMInjectRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_InjectRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, injectRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activateRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMActivateRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_ActivateRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, activateRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "variableRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMVariableRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_VariableRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, variableRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "savedArrangementRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSavedArrangementRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_SavedArrangementRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, savedArrangementRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "focusRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMFocusRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_FocusRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, focusRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMClientOriginatedMessage class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMClientOriginatedMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "submessage",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMClientOriginatedMessage_ClearSubmessageOneOfCase(ITMClientOriginatedMessage *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMServerOriginatedMessage

@implementation ITMServerOriginatedMessage

@dynamic submessageOneOfCase;
@dynamic hasId_p, id_p;
@dynamic error;
@dynamic getBufferResponse;
@dynamic getPromptResponse;
@dynamic transactionResponse;
@dynamic notificationResponse;
@dynamic registerToolResponse;
@dynamic setProfilePropertyResponse;
@dynamic listSessionsResponse;
@dynamic sendTextResponse;
@dynamic createTabResponse;
@dynamic splitPaneResponse;
@dynamic getProfilePropertyResponse;
@dynamic setPropertyResponse;
@dynamic getPropertyResponse;
@dynamic injectResponse;
@dynamic activateResponse;
@dynamic variableResponse;
@dynamic savedArrangementResponse;
@dynamic focusResponse;
@dynamic notification;

typedef struct ITMServerOriginatedMessage__storage_ {
  uint32_t _has_storage_[2];
  NSString *error;
  ITMGetBufferResponse *getBufferResponse;
  ITMGetPromptResponse *getPromptResponse;
  ITMTransactionResponse *transactionResponse;
  ITMNotificationResponse *notificationResponse;
  ITMRegisterToolResponse *registerToolResponse;
  ITMSetProfilePropertyResponse *setProfilePropertyResponse;
  ITMListSessionsResponse *listSessionsResponse;
  ITMSendTextResponse *sendTextResponse;
  ITMCreateTabResponse *createTabResponse;
  ITMSplitPaneResponse *splitPaneResponse;
  ITMGetProfilePropertyResponse *getProfilePropertyResponse;
  ITMSetPropertyResponse *setPropertyResponse;
  ITMGetPropertyResponse *getPropertyResponse;
  ITMInjectResponse *injectResponse;
  ITMActivateResponse *activateResponse;
  ITMVariableResponse *variableResponse;
  ITMSavedArrangementResponse *savedArrangementResponse;
  ITMFocusResponse *focusResponse;
  ITMNotification *notification;
  int64_t id_p;
} ITMServerOriginatedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ITMServerOriginatedMessage_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = ITMServerOriginatedMessage_FieldNumber_Error,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "getBufferResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetBufferResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_GetBufferResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, getBufferResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getPromptResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetPromptResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_GetPromptResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, getPromptResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMTransactionResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_TransactionResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, transactionResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "notificationResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMNotificationResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_NotificationResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, notificationResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "registerToolResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMRegisterToolResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_RegisterToolResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, registerToolResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setProfilePropertyResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSetProfilePropertyResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_SetProfilePropertyResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, setProfilePropertyResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listSessionsResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListSessionsResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_ListSessionsResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, listSessionsResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sendTextResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSendTextResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_SendTextResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, sendTextResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createTabResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCreateTabResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_CreateTabResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, createTabResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "splitPaneResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSplitPaneResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_SplitPaneResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, splitPaneResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getProfilePropertyResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetProfilePropertyResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_GetProfilePropertyResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, getProfilePropertyResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setPropertyResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSetPropertyResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_SetPropertyResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, setPropertyResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getPropertyResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetPropertyResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_GetPropertyResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, getPropertyResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "injectResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMInjectResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_InjectResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, injectResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activateResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMActivateResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_ActivateResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, activateResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "variableResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMVariableResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_VariableResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, variableResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "savedArrangementResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSavedArrangementResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_SavedArrangementResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, savedArrangementResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "focusResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMFocusResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_FocusResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, focusResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "notification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMNotification),
        .number = ITMServerOriginatedMessage_FieldNumber_Notification,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, notification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMServerOriginatedMessage class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMServerOriginatedMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "submessage",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMServerOriginatedMessage_ClearSubmessageOneOfCase(ITMServerOriginatedMessage *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMFocusRequest

@implementation ITMFocusRequest


typedef struct ITMFocusRequest__storage_ {
  uint32_t _has_storage_[1];
} ITMFocusRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMFocusRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ITMFocusRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMFocusResponse

@implementation ITMFocusResponse

@dynamic notificationsArray, notificationsArray_Count;

typedef struct ITMFocusResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *notificationsArray;
} ITMFocusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notificationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMFocusChangedNotification),
        .number = ITMFocusResponse_FieldNumber_NotificationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMFocusResponse__storage_, notificationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMFocusResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMFocusResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMSavedArrangementRequest

@implementation ITMSavedArrangementRequest

@dynamic hasName, name;
@dynamic hasAction, action;
@dynamic hasWindowId, windowId;

typedef struct ITMSavedArrangementRequest__storage_ {
  uint32_t _has_storage_[1];
  ITMSavedArrangementRequest_Action action;
  NSString *name;
  NSString *windowId;
} ITMSavedArrangementRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ITMSavedArrangementRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSavedArrangementRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "action",
        .dataTypeSpecific.enumDescFunc = ITMSavedArrangementRequest_Action_EnumDescriptor,
        .number = ITMSavedArrangementRequest_FieldNumber_Action,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMSavedArrangementRequest__storage_, action),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMSavedArrangementRequest_FieldNumber_WindowId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMSavedArrangementRequest__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSavedArrangementRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSavedArrangementRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMSavedArrangementRequest_Action

GPBEnumDescriptor *ITMSavedArrangementRequest_Action_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Restore\000Save\000";
    static const int32_t values[] = {
        ITMSavedArrangementRequest_Action_Restore,
        ITMSavedArrangementRequest_Action_Save,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMSavedArrangementRequest_Action)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMSavedArrangementRequest_Action_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMSavedArrangementRequest_Action_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMSavedArrangementRequest_Action_Restore:
    case ITMSavedArrangementRequest_Action_Save:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMSavedArrangementResponse

@implementation ITMSavedArrangementResponse

@dynamic hasStatus, status;

typedef struct ITMSavedArrangementResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMSavedArrangementResponse_Status status;
} ITMSavedArrangementResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMSavedArrangementResponse_Status_EnumDescriptor,
        .number = ITMSavedArrangementResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSavedArrangementResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSavedArrangementResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSavedArrangementResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMSavedArrangementResponse_Status

GPBEnumDescriptor *ITMSavedArrangementResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000ArrangementNotFound\000WindowNotFound\000Re"
        "questMalformed\000";
    static const int32_t values[] = {
        ITMSavedArrangementResponse_Status_Ok,
        ITMSavedArrangementResponse_Status_ArrangementNotFound,
        ITMSavedArrangementResponse_Status_WindowNotFound,
        ITMSavedArrangementResponse_Status_RequestMalformed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMSavedArrangementResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMSavedArrangementResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMSavedArrangementResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMSavedArrangementResponse_Status_Ok:
    case ITMSavedArrangementResponse_Status_ArrangementNotFound:
    case ITMSavedArrangementResponse_Status_WindowNotFound:
    case ITMSavedArrangementResponse_Status_RequestMalformed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMVariableRequest

@implementation ITMVariableRequest

@dynamic hasSessionId, sessionId;
@dynamic setArray, setArray_Count;
@dynamic getArray, getArray_Count;

typedef struct ITMVariableRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
  NSMutableArray *setArray;
  NSMutableArray *getArray;
} ITMVariableRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = ITMVariableRequest_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMVariableRequest__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "setArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMVariableRequest_Set),
        .number = ITMVariableRequest_FieldNumber_SetArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMVariableRequest__storage_, setArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMVariableRequest_FieldNumber_GetArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMVariableRequest__storage_, getArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMVariableRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMVariableRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMVariableRequest_Set

@implementation ITMVariableRequest_Set

@dynamic hasName, name;
@dynamic hasValue, value;

typedef struct ITMVariableRequest_Set__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *value;
} ITMVariableRequest_Set__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ITMVariableRequest_Set_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMVariableRequest_Set__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = ITMVariableRequest_Set_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMVariableRequest_Set__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMVariableRequest_Set class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMVariableRequest_Set__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMVariableRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMVariableResponse

@implementation ITMVariableResponse

@dynamic hasStatus, status;
@dynamic valuesArray, valuesArray_Count;

typedef struct ITMVariableResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMVariableResponse_Status status;
  NSMutableArray *valuesArray;
} ITMVariableResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMVariableResponse_Status_EnumDescriptor,
        .number = ITMVariableResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMVariableResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "valuesArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMVariableResponse_FieldNumber_ValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMVariableResponse__storage_, valuesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMVariableResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMVariableResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMVariableResponse_Status

GPBEnumDescriptor *ITMVariableResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000InvalidName\000";
    static const int32_t values[] = {
        ITMVariableResponse_Status_Ok,
        ITMVariableResponse_Status_SessionNotFound,
        ITMVariableResponse_Status_InvalidName,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMVariableResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMVariableResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMVariableResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMVariableResponse_Status_Ok:
    case ITMVariableResponse_Status_SessionNotFound:
    case ITMVariableResponse_Status_InvalidName:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMActivateRequest

@implementation ITMActivateRequest

@dynamic identifierOneOfCase;
@dynamic windowId;
@dynamic tabId;
@dynamic sessionId;
@dynamic hasOrderWindowFront, orderWindowFront;
@dynamic hasSelectTab, selectTab;
@dynamic hasSelectSession, selectSession;
@dynamic hasActivateApp, activateApp;

typedef struct ITMActivateRequest__storage_ {
  uint32_t _has_storage_[2];
  NSString *windowId;
  NSString *tabId;
  NSString *sessionId;
  ITMActivateRequest_App *activateApp;
} ITMActivateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMActivateRequest_FieldNumber_WindowId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMActivateRequest__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tabId",
        .dataTypeSpecific.className = NULL,
        .number = ITMActivateRequest_FieldNumber_TabId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMActivateRequest__storage_, tabId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = ITMActivateRequest_FieldNumber_SessionId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMActivateRequest__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "orderWindowFront",
        .dataTypeSpecific.className = NULL,
        .number = ITMActivateRequest_FieldNumber_OrderWindowFront,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "selectTab",
        .dataTypeSpecific.className = NULL,
        .number = ITMActivateRequest_FieldNumber_SelectTab,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "selectSession",
        .dataTypeSpecific.className = NULL,
        .number = ITMActivateRequest_FieldNumber_SelectSession,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "activateApp",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMActivateRequest_App),
        .number = ITMActivateRequest_FieldNumber_ActivateApp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ITMActivateRequest__storage_, activateApp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMActivateRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMActivateRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "identifier",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMActivateRequest_ClearIdentifierOneOfCase(ITMActivateRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMActivateRequest_App

@implementation ITMActivateRequest_App

@dynamic hasRaiseAllWindows, raiseAllWindows;
@dynamic hasIgnoringOtherApps, ignoringOtherApps;

typedef struct ITMActivateRequest_App__storage_ {
  uint32_t _has_storage_[1];
} ITMActivateRequest_App__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "raiseAllWindows",
        .dataTypeSpecific.className = NULL,
        .number = ITMActivateRequest_App_FieldNumber_RaiseAllWindows,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "ignoringOtherApps",
        .dataTypeSpecific.className = NULL,
        .number = ITMActivateRequest_App_FieldNumber_IgnoringOtherApps,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMActivateRequest_App class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMActivateRequest_App__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMActivateRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMActivateResponse

@implementation ITMActivateResponse

@dynamic hasStatus, status;

typedef struct ITMActivateResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMActivateResponse_Status status;
} ITMActivateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMActivateResponse_Status_EnumDescriptor,
        .number = ITMActivateResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMActivateResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMActivateResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMActivateResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMActivateResponse_Status

GPBEnumDescriptor *ITMActivateResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000BadIdentifier\000InvalidOption\000";
    static const int32_t values[] = {
        ITMActivateResponse_Status_Ok,
        ITMActivateResponse_Status_BadIdentifier,
        ITMActivateResponse_Status_InvalidOption,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMActivateResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMActivateResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMActivateResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMActivateResponse_Status_Ok:
    case ITMActivateResponse_Status_BadIdentifier:
    case ITMActivateResponse_Status_InvalidOption:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMInjectRequest

@implementation ITMInjectRequest

@dynamic sessionIdArray, sessionIdArray_Count;
@dynamic hasData_p, data_p;

typedef struct ITMInjectRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *sessionIdArray;
  NSData *data_p;
} ITMInjectRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionIdArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMInjectRequest_FieldNumber_SessionIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMInjectRequest__storage_, sessionIdArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = ITMInjectRequest_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMInjectRequest__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMInjectRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMInjectRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMInjectResponse

@implementation ITMInjectResponse

@dynamic statusArray, statusArray_Count;

typedef struct ITMInjectResponse__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *statusArray;
} ITMInjectResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusArray",
        .dataTypeSpecific.enumDescFunc = ITMInjectResponse_Status_EnumDescriptor,
        .number = ITMInjectResponse_FieldNumber_StatusArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMInjectResponse__storage_, statusArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMInjectResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMInjectResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMInjectResponse_Status

GPBEnumDescriptor *ITMInjectResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000";
    static const int32_t values[] = {
        ITMInjectResponse_Status_Ok,
        ITMInjectResponse_Status_SessionNotFound,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMInjectResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMInjectResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMInjectResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMInjectResponse_Status_Ok:
    case ITMInjectResponse_Status_SessionNotFound:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMGetPropertyRequest

@implementation ITMGetPropertyRequest

@dynamic identifierOneOfCase;
@dynamic windowId;
@dynamic hasName, name;

typedef struct ITMGetPropertyRequest__storage_ {
  uint32_t _has_storage_[2];
  NSString *windowId;
  NSString *name;
} ITMGetPropertyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetPropertyRequest_FieldNumber_WindowId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMGetPropertyRequest__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetPropertyRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetPropertyRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetPropertyRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetPropertyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "identifier",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMGetPropertyRequest_ClearIdentifierOneOfCase(ITMGetPropertyRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMGetPropertyResponse

@implementation ITMGetPropertyResponse

@dynamic hasStatus, status;
@dynamic hasJsonValue, jsonValue;

typedef struct ITMGetPropertyResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMGetPropertyResponse_Status status;
  NSString *jsonValue;
} ITMGetPropertyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMGetPropertyResponse_Status_EnumDescriptor,
        .number = ITMGetPropertyResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetPropertyResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "jsonValue",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetPropertyResponse_FieldNumber_JsonValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMGetPropertyResponse__storage_, jsonValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetPropertyResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetPropertyResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMGetPropertyResponse_Status

GPBEnumDescriptor *ITMGetPropertyResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000UnrecognizedName\000InvalidTarget\000";
    static const int32_t values[] = {
        ITMGetPropertyResponse_Status_Ok,
        ITMGetPropertyResponse_Status_UnrecognizedName,
        ITMGetPropertyResponse_Status_InvalidTarget,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMGetPropertyResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMGetPropertyResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMGetPropertyResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMGetPropertyResponse_Status_Ok:
    case ITMGetPropertyResponse_Status_UnrecognizedName:
    case ITMGetPropertyResponse_Status_InvalidTarget:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMSetPropertyRequest

@implementation ITMSetPropertyRequest

@dynamic identifierOneOfCase;
@dynamic windowId;
@dynamic hasName, name;
@dynamic hasJsonValue, jsonValue;

typedef struct ITMSetPropertyRequest__storage_ {
  uint32_t _has_storage_[2];
  NSString *windowId;
  NSString *name;
  NSString *jsonValue;
} ITMSetPropertyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMSetPropertyRequest_FieldNumber_WindowId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMSetPropertyRequest__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ITMSetPropertyRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSetPropertyRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jsonValue",
        .dataTypeSpecific.className = NULL,
        .number = ITMSetPropertyRequest_FieldNumber_JsonValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMSetPropertyRequest__storage_, jsonValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSetPropertyRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSetPropertyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "identifier",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMSetPropertyRequest_ClearIdentifierOneOfCase(ITMSetPropertyRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMSetPropertyResponse

@implementation ITMSetPropertyResponse

@dynamic hasStatus, status;

typedef struct ITMSetPropertyResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMSetPropertyResponse_Status status;
} ITMSetPropertyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMSetPropertyResponse_Status_EnumDescriptor,
        .number = ITMSetPropertyResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSetPropertyResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSetPropertyResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSetPropertyResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMSetPropertyResponse_Status

GPBEnumDescriptor *ITMSetPropertyResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000UnrecognizedName\000InvalidValue\000Invalid"
        "Target\000";
    static const int32_t values[] = {
        ITMSetPropertyResponse_Status_Ok,
        ITMSetPropertyResponse_Status_UnrecognizedName,
        ITMSetPropertyResponse_Status_InvalidValue,
        ITMSetPropertyResponse_Status_InvalidTarget,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMSetPropertyResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMSetPropertyResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMSetPropertyResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMSetPropertyResponse_Status_Ok:
    case ITMSetPropertyResponse_Status_UnrecognizedName:
    case ITMSetPropertyResponse_Status_InvalidValue:
    case ITMSetPropertyResponse_Status_InvalidTarget:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMRegisterToolRequest

@implementation ITMRegisterToolRequest

@dynamic hasName, name;
@dynamic hasIdentifier, identifier;
@dynamic hasRevealIfAlreadyRegistered, revealIfAlreadyRegistered;
@dynamic hasToolType, toolType;
@dynamic hasURL, URL;

typedef struct ITMRegisterToolRequest__storage_ {
  uint32_t _has_storage_[1];
  ITMRegisterToolRequest_ToolType toolType;
  NSString *name;
  NSString *identifier;
  NSString *URL;
} ITMRegisterToolRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "name",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMRegisterToolRequest_FieldNumber_Name,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ITMRegisterToolRequest__storage_, name),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "identifier",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMRegisterToolRequest_FieldNumber_Identifier,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ITMRegisterToolRequest__storage_, identifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ITMRegisterToolRequest_ToolType_WebViewTool,
        .core.name = "toolType",
        .core.dataTypeSpecific.enumDescFunc = ITMRegisterToolRequest_ToolType_EnumDescriptor,
        .core.number = ITMRegisterToolRequest_FieldNumber_ToolType,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ITMRegisterToolRequest__storage_, toolType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "URL",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMRegisterToolRequest_FieldNumber_URL,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(ITMRegisterToolRequest__storage_, URL),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "revealIfAlreadyRegistered",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMRegisterToolRequest_FieldNumber_RevealIfAlreadyRegistered,
        .core.hasIndex = 2,
        .core.offset = 3,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMRegisterToolRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ITMRegisterToolRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\003\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMRegisterToolRequest_ToolType

GPBEnumDescriptor *ITMRegisterToolRequest_ToolType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "WebViewTool\000";
    static const int32_t values[] = {
        ITMRegisterToolRequest_ToolType_WebViewTool,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMRegisterToolRequest_ToolType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMRegisterToolRequest_ToolType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMRegisterToolRequest_ToolType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMRegisterToolRequest_ToolType_WebViewTool:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMRegisterToolResponse

@implementation ITMRegisterToolResponse

@dynamic hasStatus, status;

typedef struct ITMRegisterToolResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMRegisterToolResponse_Status status;
} ITMRegisterToolResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMRegisterToolResponse_Status_EnumDescriptor,
        .number = ITMRegisterToolResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMRegisterToolResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMRegisterToolResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMRegisterToolResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMRegisterToolResponse_Status

GPBEnumDescriptor *ITMRegisterToolResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000RequestMalformed\000PermissionDenied\000";
    static const int32_t values[] = {
        ITMRegisterToolResponse_Status_Ok,
        ITMRegisterToolResponse_Status_RequestMalformed,
        ITMRegisterToolResponse_Status_PermissionDenied,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMRegisterToolResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMRegisterToolResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMRegisterToolResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMRegisterToolResponse_Status_Ok:
    case ITMRegisterToolResponse_Status_RequestMalformed:
    case ITMRegisterToolResponse_Status_PermissionDenied:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMNotificationRequest

@implementation ITMNotificationRequest

@dynamic hasSession, session;
@dynamic hasSubscribe, subscribe;
@dynamic hasNotificationType, notificationType;

typedef struct ITMNotificationRequest__storage_ {
  uint32_t _has_storage_[1];
  ITMNotificationType notificationType;
  NSString *session;
} ITMNotificationRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "session",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMNotificationRequest_FieldNumber_Session,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ITMNotificationRequest__storage_, session),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "subscribe",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMNotificationRequest_FieldNumber_Subscribe,
        .core.hasIndex = 1,
        .core.offset = 2,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueEnum = ITMNotificationType_NotifyOnKeystroke,
        .core.name = "notificationType",
        .core.dataTypeSpecific.enumDescFunc = ITMNotificationType_EnumDescriptor,
        .core.number = ITMNotificationRequest_FieldNumber_NotificationType,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ITMNotificationRequest__storage_, notificationType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMNotificationRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ITMNotificationRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMNotificationResponse

@implementation ITMNotificationResponse

@dynamic hasStatus, status;

typedef struct ITMNotificationResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMNotificationResponse_Status status;
} ITMNotificationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMNotificationResponse_Status_EnumDescriptor,
        .number = ITMNotificationResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMNotificationResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMNotificationResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMNotificationResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMNotificationResponse_Status

GPBEnumDescriptor *ITMNotificationResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000RequestMalformed\000NotS"
        "ubscribed\000AlreadySubscribed\000";
    static const int32_t values[] = {
        ITMNotificationResponse_Status_Ok,
        ITMNotificationResponse_Status_SessionNotFound,
        ITMNotificationResponse_Status_RequestMalformed,
        ITMNotificationResponse_Status_NotSubscribed,
        ITMNotificationResponse_Status_AlreadySubscribed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMNotificationResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMNotificationResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMNotificationResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMNotificationResponse_Status_Ok:
    case ITMNotificationResponse_Status_SessionNotFound:
    case ITMNotificationResponse_Status_RequestMalformed:
    case ITMNotificationResponse_Status_NotSubscribed:
    case ITMNotificationResponse_Status_AlreadySubscribed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMNotification

@implementation ITMNotification

@dynamic hasKeystrokeNotification, keystrokeNotification;
@dynamic hasScreenUpdateNotification, screenUpdateNotification;
@dynamic hasPromptNotification, promptNotification;
@dynamic hasLocationChangeNotification, locationChangeNotification;
@dynamic hasCustomEscapeSequenceNotification, customEscapeSequenceNotification;
@dynamic hasNewSessionNotification, newSessionNotification;
@dynamic hasTerminateSessionNotification, terminateSessionNotification;
@dynamic hasLayoutChangedNotification, layoutChangedNotification;
@dynamic hasFocusChangedNotification, focusChangedNotification;

typedef struct ITMNotification__storage_ {
  uint32_t _has_storage_[1];
  ITMKeystrokeNotification *keystrokeNotification;
  ITMScreenUpdateNotification *screenUpdateNotification;
  ITMPromptNotification *promptNotification;
  ITMLocationChangeNotification *locationChangeNotification;
  ITMCustomEscapeSequenceNotification *customEscapeSequenceNotification;
  ITMNewSessionNotification *newSessionNotification;
  ITMTerminateSessionNotification *terminateSessionNotification;
  ITMLayoutChangedNotification *layoutChangedNotification;
  ITMFocusChangedNotification *focusChangedNotification;
} ITMNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keystrokeNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMKeystrokeNotification),
        .number = ITMNotification_FieldNumber_KeystrokeNotification,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, keystrokeNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "screenUpdateNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMScreenUpdateNotification),
        .number = ITMNotification_FieldNumber_ScreenUpdateNotification,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, screenUpdateNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "promptNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMPromptNotification),
        .number = ITMNotification_FieldNumber_PromptNotification,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, promptNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "locationChangeNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMLocationChangeNotification),
        .number = ITMNotification_FieldNumber_LocationChangeNotification,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, locationChangeNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "customEscapeSequenceNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCustomEscapeSequenceNotification),
        .number = ITMNotification_FieldNumber_CustomEscapeSequenceNotification,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, customEscapeSequenceNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newSessionNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMNewSessionNotification),
        .number = ITMNotification_FieldNumber_NewSessionNotification,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, newSessionNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "terminateSessionNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMTerminateSessionNotification),
        .number = ITMNotification_FieldNumber_TerminateSessionNotification,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, terminateSessionNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "layoutChangedNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMLayoutChangedNotification),
        .number = ITMNotification_FieldNumber_LayoutChangedNotification,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, layoutChangedNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "focusChangedNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMFocusChangedNotification),
        .number = ITMNotification_FieldNumber_FocusChangedNotification,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, focusChangedNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMKeystrokeNotification

@implementation ITMKeystrokeNotification

@dynamic hasCharacters, characters;
@dynamic hasCharactersIgnoringModifiers, charactersIgnoringModifiers;
@dynamic modifiersArray, modifiersArray_Count;
@dynamic hasKeyCode, keyCode;
@dynamic hasSession, session;

typedef struct ITMKeystrokeNotification__storage_ {
  uint32_t _has_storage_[1];
  int32_t keyCode;
  NSString *characters;
  NSString *charactersIgnoringModifiers;
  GPBEnumArray *modifiersArray;
  NSString *session;
} ITMKeystrokeNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "characters",
        .dataTypeSpecific.className = NULL,
        .number = ITMKeystrokeNotification_FieldNumber_Characters,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMKeystrokeNotification__storage_, characters),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "charactersIgnoringModifiers",
        .dataTypeSpecific.className = NULL,
        .number = ITMKeystrokeNotification_FieldNumber_CharactersIgnoringModifiers,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMKeystrokeNotification__storage_, charactersIgnoringModifiers),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "modifiersArray",
        .dataTypeSpecific.enumDescFunc = ITMKeystrokeNotification_Modifiers_EnumDescriptor,
        .number = ITMKeystrokeNotification_FieldNumber_ModifiersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMKeystrokeNotification__storage_, modifiersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "keyCode",
        .dataTypeSpecific.className = NULL,
        .number = ITMKeystrokeNotification_FieldNumber_KeyCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMKeystrokeNotification__storage_, keyCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMKeystrokeNotification_FieldNumber_Session,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMKeystrokeNotification__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMKeystrokeNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMKeystrokeNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\033\000\004\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMKeystrokeNotification_Modifiers

GPBEnumDescriptor *ITMKeystrokeNotification_Modifiers_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Control\000Option\000Command\000Shift\000Function\000Nu"
        "mpad\000";
    static const int32_t values[] = {
        ITMKeystrokeNotification_Modifiers_Control,
        ITMKeystrokeNotification_Modifiers_Option,
        ITMKeystrokeNotification_Modifiers_Command,
        ITMKeystrokeNotification_Modifiers_Shift,
        ITMKeystrokeNotification_Modifiers_Function,
        ITMKeystrokeNotification_Modifiers_Numpad,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMKeystrokeNotification_Modifiers)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMKeystrokeNotification_Modifiers_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMKeystrokeNotification_Modifiers_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMKeystrokeNotification_Modifiers_Control:
    case ITMKeystrokeNotification_Modifiers_Option:
    case ITMKeystrokeNotification_Modifiers_Command:
    case ITMKeystrokeNotification_Modifiers_Shift:
    case ITMKeystrokeNotification_Modifiers_Function:
    case ITMKeystrokeNotification_Modifiers_Numpad:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMScreenUpdateNotification

@implementation ITMScreenUpdateNotification

@dynamic hasSession, session;

typedef struct ITMScreenUpdateNotification__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
} ITMScreenUpdateNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMScreenUpdateNotification_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMScreenUpdateNotification__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMScreenUpdateNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMScreenUpdateNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMPromptNotification

@implementation ITMPromptNotification

@dynamic hasSession, session;

typedef struct ITMPromptNotification__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
} ITMPromptNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMPromptNotification_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMPromptNotification__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMPromptNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMPromptNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMLocationChangeNotification

@implementation ITMLocationChangeNotification

@dynamic hasHostName, hostName;
@dynamic hasUserName, userName;
@dynamic hasDirectory, directory;
@dynamic hasSession, session;

typedef struct ITMLocationChangeNotification__storage_ {
  uint32_t _has_storage_[1];
  NSString *hostName;
  NSString *userName;
  NSString *directory;
  NSString *session;
} ITMLocationChangeNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hostName",
        .dataTypeSpecific.className = NULL,
        .number = ITMLocationChangeNotification_FieldNumber_HostName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMLocationChangeNotification__storage_, hostName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ITMLocationChangeNotification_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMLocationChangeNotification__storage_, userName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "directory",
        .dataTypeSpecific.className = NULL,
        .number = ITMLocationChangeNotification_FieldNumber_Directory,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMLocationChangeNotification__storage_, directory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMLocationChangeNotification_FieldNumber_Session,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMLocationChangeNotification__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMLocationChangeNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMLocationChangeNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMCustomEscapeSequenceNotification

@implementation ITMCustomEscapeSequenceNotification

@dynamic hasSession, session;
@dynamic hasSenderIdentity, senderIdentity;
@dynamic hasPayload, payload;

typedef struct ITMCustomEscapeSequenceNotification__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
  NSString *senderIdentity;
  NSString *payload;
} ITMCustomEscapeSequenceNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMCustomEscapeSequenceNotification_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMCustomEscapeSequenceNotification__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "senderIdentity",
        .dataTypeSpecific.className = NULL,
        .number = ITMCustomEscapeSequenceNotification_FieldNumber_SenderIdentity,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMCustomEscapeSequenceNotification__storage_, senderIdentity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payload",
        .dataTypeSpecific.className = NULL,
        .number = ITMCustomEscapeSequenceNotification_FieldNumber_Payload,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMCustomEscapeSequenceNotification__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMCustomEscapeSequenceNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMCustomEscapeSequenceNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMNewSessionNotification

@implementation ITMNewSessionNotification

@dynamic hasUniqueIdentifier, uniqueIdentifier;

typedef struct ITMNewSessionNotification__storage_ {
  uint32_t _has_storage_[1];
  NSString *uniqueIdentifier;
} ITMNewSessionNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uniqueIdentifier",
        .dataTypeSpecific.className = NULL,
        .number = ITMNewSessionNotification_FieldNumber_UniqueIdentifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMNewSessionNotification__storage_, uniqueIdentifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMNewSessionNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMNewSessionNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMFocusChangedNotification

@implementation ITMFocusChangedNotification

@dynamic eventOneOfCase;
@dynamic applicationActive;
@dynamic window;
@dynamic selectedTab;
@dynamic session;

typedef struct ITMFocusChangedNotification__storage_ {
  uint32_t _has_storage_[2];
  ITMFocusChangedNotification_Window *window;
  NSString *selectedTab;
  NSString *session;
} ITMFocusChangedNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "applicationActive",
        .dataTypeSpecific.className = NULL,
        .number = ITMFocusChangedNotification_FieldNumber_ApplicationActive,
        .hasIndex = -1,
        .offset = 0,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "window",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMFocusChangedNotification_Window),
        .number = ITMFocusChangedNotification_FieldNumber_Window,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMFocusChangedNotification__storage_, window),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "selectedTab",
        .dataTypeSpecific.className = NULL,
        .number = ITMFocusChangedNotification_FieldNumber_SelectedTab,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMFocusChangedNotification__storage_, selectedTab),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMFocusChangedNotification_FieldNumber_Session,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMFocusChangedNotification__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMFocusChangedNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMFocusChangedNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "event",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMFocusChangedNotification_ClearEventOneOfCase(ITMFocusChangedNotification *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMFocusChangedNotification_Window

@implementation ITMFocusChangedNotification_Window

@dynamic hasWindowStatus, windowStatus;
@dynamic hasWindowId, windowId;

typedef struct ITMFocusChangedNotification_Window__storage_ {
  uint32_t _has_storage_[1];
  ITMFocusChangedNotification_Window_WindowStatus windowStatus;
  NSString *windowId;
} ITMFocusChangedNotification_Window__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "windowStatus",
        .dataTypeSpecific.enumDescFunc = ITMFocusChangedNotification_Window_WindowStatus_EnumDescriptor,
        .number = ITMFocusChangedNotification_Window_FieldNumber_WindowStatus,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMFocusChangedNotification_Window__storage_, windowStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMFocusChangedNotification_Window_FieldNumber_WindowId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMFocusChangedNotification_Window__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMFocusChangedNotification_Window class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMFocusChangedNotification_Window__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMFocusChangedNotification)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMFocusChangedNotification_Window_WindowStatus

GPBEnumDescriptor *ITMFocusChangedNotification_Window_WindowStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "TerminalWindowBecameKey\000TerminalWindowIs"
        "Current\000TerminalWindowResignedKey\000";
    static const int32_t values[] = {
        ITMFocusChangedNotification_Window_WindowStatus_TerminalWindowBecameKey,
        ITMFocusChangedNotification_Window_WindowStatus_TerminalWindowIsCurrent,
        ITMFocusChangedNotification_Window_WindowStatus_TerminalWindowResignedKey,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMFocusChangedNotification_Window_WindowStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMFocusChangedNotification_Window_WindowStatus_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMFocusChangedNotification_Window_WindowStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMFocusChangedNotification_Window_WindowStatus_TerminalWindowBecameKey:
    case ITMFocusChangedNotification_Window_WindowStatus_TerminalWindowIsCurrent:
    case ITMFocusChangedNotification_Window_WindowStatus_TerminalWindowResignedKey:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMTerminateSessionNotification

@implementation ITMTerminateSessionNotification

@dynamic hasUniqueIdentifier, uniqueIdentifier;

typedef struct ITMTerminateSessionNotification__storage_ {
  uint32_t _has_storage_[1];
  NSString *uniqueIdentifier;
} ITMTerminateSessionNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uniqueIdentifier",
        .dataTypeSpecific.className = NULL,
        .number = ITMTerminateSessionNotification_FieldNumber_UniqueIdentifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMTerminateSessionNotification__storage_, uniqueIdentifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMTerminateSessionNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMTerminateSessionNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMLayoutChangedNotification

@implementation ITMLayoutChangedNotification

@dynamic hasListSessionsResponse, listSessionsResponse;

typedef struct ITMLayoutChangedNotification__storage_ {
  uint32_t _has_storage_[1];
  ITMListSessionsResponse *listSessionsResponse;
} ITMLayoutChangedNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listSessionsResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListSessionsResponse),
        .number = ITMLayoutChangedNotification_FieldNumber_ListSessionsResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMLayoutChangedNotification__storage_, listSessionsResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMLayoutChangedNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMLayoutChangedNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMGetBufferRequest

@implementation ITMGetBufferRequest

@dynamic hasSession, session;
@dynamic hasLineRange, lineRange;

typedef struct ITMGetBufferRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
  ITMLineRange *lineRange;
} ITMGetBufferRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetBufferRequest_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetBufferRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lineRange",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMLineRange),
        .number = ITMGetBufferRequest_FieldNumber_LineRange,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMGetBufferRequest__storage_, lineRange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetBufferRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetBufferRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMGetBufferResponse

@implementation ITMGetBufferResponse

@dynamic hasStatus, status;
@dynamic hasRange, range;
@dynamic contentsArray, contentsArray_Count;
@dynamic hasCursor, cursor;
@dynamic hasNumLinesAboveScreen, numLinesAboveScreen;

typedef struct ITMGetBufferResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMGetBufferResponse_Status status;
  ITMRange *range;
  NSMutableArray *contentsArray;
  ITMCoord *cursor;
  int64_t numLinesAboveScreen;
} ITMGetBufferResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMGetBufferResponse_Status_EnumDescriptor,
        .number = ITMGetBufferResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetBufferResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "range",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMRange),
        .number = ITMGetBufferResponse_FieldNumber_Range,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMGetBufferResponse__storage_, range),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contentsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMLineContents),
        .number = ITMGetBufferResponse_FieldNumber_ContentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMGetBufferResponse__storage_, contentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cursor",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCoord),
        .number = ITMGetBufferResponse_FieldNumber_Cursor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMGetBufferResponse__storage_, cursor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "numLinesAboveScreen",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetBufferResponse_FieldNumber_NumLinesAboveScreen,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMGetBufferResponse__storage_, numLinesAboveScreen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetBufferResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetBufferResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMGetBufferResponse_Status

GPBEnumDescriptor *ITMGetBufferResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000InvalidLineRange\000Requ"
        "estMalformed\000";
    static const int32_t values[] = {
        ITMGetBufferResponse_Status_Ok,
        ITMGetBufferResponse_Status_SessionNotFound,
        ITMGetBufferResponse_Status_InvalidLineRange,
        ITMGetBufferResponse_Status_RequestMalformed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMGetBufferResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMGetBufferResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMGetBufferResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMGetBufferResponse_Status_Ok:
    case ITMGetBufferResponse_Status_SessionNotFound:
    case ITMGetBufferResponse_Status_InvalidLineRange:
    case ITMGetBufferResponse_Status_RequestMalformed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMGetPromptRequest

@implementation ITMGetPromptRequest

@dynamic hasSession, session;

typedef struct ITMGetPromptRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
} ITMGetPromptRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetPromptRequest_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetPromptRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetPromptRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetPromptRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMGetPromptResponse

@implementation ITMGetPromptResponse

@dynamic hasStatus, status;
@dynamic hasPromptRange, promptRange;
@dynamic hasCommandRange, commandRange;
@dynamic hasOutputRange, outputRange;
@dynamic hasWorkingDirectory, workingDirectory;
@dynamic hasCommand, command;

typedef struct ITMGetPromptResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMGetPromptResponse_Status status;
  ITMCoordRange *promptRange;
  ITMCoordRange *commandRange;
  ITMCoordRange *outputRange;
  NSString *workingDirectory;
  NSString *command;
} ITMGetPromptResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMGetPromptResponse_Status_EnumDescriptor,
        .number = ITMGetPromptResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetPromptResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "promptRange",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCoordRange),
        .number = ITMGetPromptResponse_FieldNumber_PromptRange,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMGetPromptResponse__storage_, promptRange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commandRange",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCoordRange),
        .number = ITMGetPromptResponse_FieldNumber_CommandRange,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMGetPromptResponse__storage_, commandRange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputRange",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCoordRange),
        .number = ITMGetPromptResponse_FieldNumber_OutputRange,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMGetPromptResponse__storage_, outputRange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "workingDirectory",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetPromptResponse_FieldNumber_WorkingDirectory,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ITMGetPromptResponse__storage_, workingDirectory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "command",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetPromptResponse_FieldNumber_Command,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ITMGetPromptResponse__storage_, command),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetPromptResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetPromptResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMGetPromptResponse_Status

GPBEnumDescriptor *ITMGetPromptResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000RequestMalformed\000Prom"
        "ptUnavailable\000";
    static const int32_t values[] = {
        ITMGetPromptResponse_Status_Ok,
        ITMGetPromptResponse_Status_SessionNotFound,
        ITMGetPromptResponse_Status_RequestMalformed,
        ITMGetPromptResponse_Status_PromptUnavailable,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMGetPromptResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMGetPromptResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMGetPromptResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMGetPromptResponse_Status_Ok:
    case ITMGetPromptResponse_Status_SessionNotFound:
    case ITMGetPromptResponse_Status_RequestMalformed:
    case ITMGetPromptResponse_Status_PromptUnavailable:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMGetProfilePropertyRequest

@implementation ITMGetProfilePropertyRequest

@dynamic hasSession, session;
@dynamic keysArray, keysArray_Count;

typedef struct ITMGetProfilePropertyRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
  NSMutableArray *keysArray;
} ITMGetProfilePropertyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetProfilePropertyRequest_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetProfilePropertyRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keysArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetProfilePropertyRequest_FieldNumber_KeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMGetProfilePropertyRequest__storage_, keysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetProfilePropertyRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetProfilePropertyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMGetProfilePropertyResponse

@implementation ITMGetProfilePropertyResponse

@dynamic hasStatus, status;
@dynamic propertiesArray, propertiesArray_Count;

typedef struct ITMGetProfilePropertyResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMGetProfilePropertyResponse_Status status;
  NSMutableArray *propertiesArray;
} ITMGetProfilePropertyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMGetProfilePropertyResponse_Status_EnumDescriptor,
        .number = ITMGetProfilePropertyResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetProfilePropertyResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "propertiesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetProfilePropertyResponse_Property),
        .number = ITMGetProfilePropertyResponse_FieldNumber_PropertiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMGetProfilePropertyResponse__storage_, propertiesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetProfilePropertyResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetProfilePropertyResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMGetProfilePropertyResponse_Status

GPBEnumDescriptor *ITMGetProfilePropertyResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000RequestMalformed\000Erro"
        "r\000";
    static const int32_t values[] = {
        ITMGetProfilePropertyResponse_Status_Ok,
        ITMGetProfilePropertyResponse_Status_SessionNotFound,
        ITMGetProfilePropertyResponse_Status_RequestMalformed,
        ITMGetProfilePropertyResponse_Status_Error,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMGetProfilePropertyResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMGetProfilePropertyResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMGetProfilePropertyResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMGetProfilePropertyResponse_Status_Ok:
    case ITMGetProfilePropertyResponse_Status_SessionNotFound:
    case ITMGetProfilePropertyResponse_Status_RequestMalformed:
    case ITMGetProfilePropertyResponse_Status_Error:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMGetProfilePropertyResponse_Property

@implementation ITMGetProfilePropertyResponse_Property

@dynamic hasKey, key;
@dynamic hasJsonValue, jsonValue;

typedef struct ITMGetProfilePropertyResponse_Property__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *jsonValue;
} ITMGetProfilePropertyResponse_Property__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetProfilePropertyResponse_Property_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetProfilePropertyResponse_Property__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jsonValue",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetProfilePropertyResponse_Property_FieldNumber_JsonValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMGetProfilePropertyResponse_Property__storage_, jsonValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetProfilePropertyResponse_Property class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetProfilePropertyResponse_Property__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMGetProfilePropertyResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMSetProfilePropertyRequest

@implementation ITMSetProfilePropertyRequest

@dynamic hasSession, session;
@dynamic hasKey, key;
@dynamic hasJsonValue, jsonValue;

typedef struct ITMSetProfilePropertyRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
  NSString *key;
  NSString *jsonValue;
} ITMSetProfilePropertyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMSetProfilePropertyRequest_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSetProfilePropertyRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = ITMSetProfilePropertyRequest_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMSetProfilePropertyRequest__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jsonValue",
        .dataTypeSpecific.className = NULL,
        .number = ITMSetProfilePropertyRequest_FieldNumber_JsonValue,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMSetProfilePropertyRequest__storage_, jsonValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSetProfilePropertyRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSetProfilePropertyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMSetProfilePropertyResponse

@implementation ITMSetProfilePropertyResponse

@dynamic hasStatus, status;

typedef struct ITMSetProfilePropertyResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMSetProfilePropertyResponse_Status status;
} ITMSetProfilePropertyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMSetProfilePropertyResponse_Status_EnumDescriptor,
        .number = ITMSetProfilePropertyResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSetProfilePropertyResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSetProfilePropertyResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSetProfilePropertyResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMSetProfilePropertyResponse_Status

GPBEnumDescriptor *ITMSetProfilePropertyResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000RequestMalformed\000";
    static const int32_t values[] = {
        ITMSetProfilePropertyResponse_Status_Ok,
        ITMSetProfilePropertyResponse_Status_SessionNotFound,
        ITMSetProfilePropertyResponse_Status_RequestMalformed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMSetProfilePropertyResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMSetProfilePropertyResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMSetProfilePropertyResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMSetProfilePropertyResponse_Status_Ok:
    case ITMSetProfilePropertyResponse_Status_SessionNotFound:
    case ITMSetProfilePropertyResponse_Status_RequestMalformed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMTransactionRequest

@implementation ITMTransactionRequest

@dynamic hasBegin, begin;

typedef struct ITMTransactionRequest__storage_ {
  uint32_t _has_storage_[1];
} ITMTransactionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "begin",
        .dataTypeSpecific.className = NULL,
        .number = ITMTransactionRequest_FieldNumber_Begin,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMTransactionRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMTransactionRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMTransactionResponse

@implementation ITMTransactionResponse

@dynamic hasStatus, status;

typedef struct ITMTransactionResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMTransactionResponse_Status status;
} ITMTransactionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMTransactionResponse_Status_EnumDescriptor,
        .number = ITMTransactionResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMTransactionResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMTransactionResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMTransactionResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMTransactionResponse_Status

GPBEnumDescriptor *ITMTransactionResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000NoTransaction\000AlreadyInTransaction\000";
    static const int32_t values[] = {
        ITMTransactionResponse_Status_Ok,
        ITMTransactionResponse_Status_NoTransaction,
        ITMTransactionResponse_Status_AlreadyInTransaction,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMTransactionResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMTransactionResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMTransactionResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMTransactionResponse_Status_Ok:
    case ITMTransactionResponse_Status_NoTransaction:
    case ITMTransactionResponse_Status_AlreadyInTransaction:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMLineRange

@implementation ITMLineRange

@dynamic hasScreenContentsOnly, screenContentsOnly;
@dynamic hasTrailingLines, trailingLines;

typedef struct ITMLineRange__storage_ {
  uint32_t _has_storage_[1];
  int32_t trailingLines;
} ITMLineRange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "screenContentsOnly",
        .dataTypeSpecific.className = NULL,
        .number = ITMLineRange_FieldNumber_ScreenContentsOnly,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "trailingLines",
        .dataTypeSpecific.className = NULL,
        .number = ITMLineRange_FieldNumber_TrailingLines,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMLineRange__storage_, trailingLines),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMLineRange class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMLineRange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMRange

@implementation ITMRange

@dynamic hasLocation, location;
@dynamic hasLength, length;

typedef struct ITMRange__storage_ {
  uint32_t _has_storage_[1];
  int64_t location;
  int64_t length;
} ITMRange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "location",
        .dataTypeSpecific.className = NULL,
        .number = ITMRange_FieldNumber_Location,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMRange__storage_, location),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "length",
        .dataTypeSpecific.className = NULL,
        .number = ITMRange_FieldNumber_Length,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMRange__storage_, length),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMRange class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMRange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMCoordRange

@implementation ITMCoordRange

@dynamic hasStart, start;
@dynamic hasEnd, end;

typedef struct ITMCoordRange__storage_ {
  uint32_t _has_storage_[1];
  ITMCoord *start;
  ITMCoord *end;
} ITMCoordRange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCoord),
        .number = ITMCoordRange_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMCoordRange__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCoord),
        .number = ITMCoordRange_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMCoordRange__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMCoordRange class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMCoordRange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMCoord

@implementation ITMCoord

@dynamic hasX, x;
@dynamic hasY, y;

typedef struct ITMCoord__storage_ {
  uint32_t _has_storage_[1];
  int32_t x;
  int64_t y;
} ITMCoord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = ITMCoord_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMCoord__storage_, x),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = ITMCoord_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMCoord__storage_, y),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMCoord class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMCoord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMLineContents

@implementation ITMLineContents

@dynamic hasText, text;
@dynamic codePointsPerCellArray, codePointsPerCellArray_Count;
@dynamic hasContinuation, continuation;

typedef struct ITMLineContents__storage_ {
  uint32_t _has_storage_[1];
  ITMLineContents_Continuation continuation;
  NSString *text;
  NSMutableArray *codePointsPerCellArray;
} ITMLineContents__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "text",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMLineContents_FieldNumber_Text,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ITMLineContents__storage_, text),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "codePointsPerCellArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ITMCodePointsPerCell),
        .core.number = ITMLineContents_FieldNumber_CodePointsPerCellArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ITMLineContents__storage_, codePointsPerCellArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ITMLineContents_Continuation_ContinuationHardEol,
        .core.name = "continuation",
        .core.dataTypeSpecific.enumDescFunc = ITMLineContents_Continuation_EnumDescriptor,
        .core.number = ITMLineContents_FieldNumber_Continuation,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ITMLineContents__storage_, continuation),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMLineContents class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ITMLineContents__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMLineContents_Continuation

GPBEnumDescriptor *ITMLineContents_Continuation_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ContinuationHardEol\000ContinuationSoftEol\000";
    static const int32_t values[] = {
        ITMLineContents_Continuation_ContinuationHardEol,
        ITMLineContents_Continuation_ContinuationSoftEol,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMLineContents_Continuation)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMLineContents_Continuation_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMLineContents_Continuation_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMLineContents_Continuation_ContinuationHardEol:
    case ITMLineContents_Continuation_ContinuationSoftEol:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMCodePointsPerCell

@implementation ITMCodePointsPerCell

@dynamic hasNumCodePoints, numCodePoints;
@dynamic hasRepeats, repeats;

typedef struct ITMCodePointsPerCell__storage_ {
  uint32_t _has_storage_[1];
  int32_t numCodePoints;
  int32_t repeats;
} ITMCodePointsPerCell__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueInt32 = 1,
        .core.name = "numCodePoints",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMCodePointsPerCell_FieldNumber_NumCodePoints,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ITMCodePointsPerCell__storage_, numCodePoints),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "repeats",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMCodePointsPerCell_FieldNumber_Repeats,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ITMCodePointsPerCell__storage_, repeats),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMCodePointsPerCell class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ITMCodePointsPerCell__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMListSessionsRequest

@implementation ITMListSessionsRequest


typedef struct ITMListSessionsRequest__storage_ {
  uint32_t _has_storage_[1];
} ITMListSessionsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMListSessionsRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ITMListSessionsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMSendTextRequest

@implementation ITMSendTextRequest

@dynamic hasSession, session;
@dynamic hasText, text;

typedef struct ITMSendTextRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
  NSString *text;
} ITMSendTextRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMSendTextRequest_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSendTextRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = ITMSendTextRequest_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMSendTextRequest__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSendTextRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSendTextRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMSendTextResponse

@implementation ITMSendTextResponse

@dynamic hasStatus, status;

typedef struct ITMSendTextResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMSendTextResponse_Status status;
} ITMSendTextResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMSendTextResponse_Status_EnumDescriptor,
        .number = ITMSendTextResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSendTextResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSendTextResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSendTextResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMSendTextResponse_Status

GPBEnumDescriptor *ITMSendTextResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000";
    static const int32_t values[] = {
        ITMSendTextResponse_Status_Ok,
        ITMSendTextResponse_Status_SessionNotFound,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMSendTextResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMSendTextResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMSendTextResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMSendTextResponse_Status_Ok:
    case ITMSendTextResponse_Status_SessionNotFound:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMSize

@implementation ITMSize

@dynamic hasWidth, width;
@dynamic hasHeight, height;

typedef struct ITMSize__storage_ {
  uint32_t _has_storage_[1];
  int32_t width;
  int32_t height;
} ITMSize__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = ITMSize_FieldNumber_Width,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSize__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = ITMSize_FieldNumber_Height,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMSize__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSize class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSize__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMPoint

@implementation ITMPoint

@dynamic hasX, x;
@dynamic hasY, y;

typedef struct ITMPoint__storage_ {
  uint32_t _has_storage_[1];
  int32_t x;
  int32_t y;
} ITMPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = ITMPoint_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMPoint__storage_, x),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = ITMPoint_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMPoint__storage_, y),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMPoint class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMPoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMFrame

@implementation ITMFrame

@dynamic hasOrigin, origin;
@dynamic hasSize, size;

typedef struct ITMFrame__storage_ {
  uint32_t _has_storage_[1];
  ITMPoint *origin;
  ITMSize *size;
} ITMFrame__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "origin",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMPoint),
        .number = ITMFrame_FieldNumber_Origin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMFrame__storage_, origin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSize),
        .number = ITMFrame_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMFrame__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMFrame class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMFrame__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMListSessionsResponse

@implementation ITMListSessionsResponse

@dynamic windowsArray, windowsArray_Count;

typedef struct ITMListSessionsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *windowsArray;
} ITMListSessionsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "windowsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListSessionsResponse_Window),
        .number = ITMListSessionsResponse_FieldNumber_WindowsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse__storage_, windowsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMListSessionsResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMListSessionsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMListSessionsResponse_Window

@implementation ITMListSessionsResponse_Window

@dynamic tabsArray, tabsArray_Count;
@dynamic hasWindowId, windowId;
@dynamic hasFrame, frame;

typedef struct ITMListSessionsResponse_Window__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tabsArray;
  NSString *windowId;
  ITMFrame *frame;
} ITMListSessionsResponse_Window__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tabsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListSessionsResponse_Tab),
        .number = ITMListSessionsResponse_Window_FieldNumber_TabsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_Window__storage_, tabsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMListSessionsResponse_Window_FieldNumber_WindowId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_Window__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "frame",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMFrame),
        .number = ITMListSessionsResponse_Window_FieldNumber_Frame,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_Window__storage_, frame),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMListSessionsResponse_Window class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMListSessionsResponse_Window__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMListSessionsResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMListSessionsResponse_Tab

@implementation ITMListSessionsResponse_Tab

@dynamic hasRoot, root;
@dynamic hasTabId, tabId;

typedef struct ITMListSessionsResponse_Tab__storage_ {
  uint32_t _has_storage_[1];
  NSString *tabId;
  ITMListSessionsResponse_SplitTreeNode *root;
} ITMListSessionsResponse_Tab__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tabId",
        .dataTypeSpecific.className = NULL,
        .number = ITMListSessionsResponse_Tab_FieldNumber_TabId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_Tab__storage_, tabId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "root",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListSessionsResponse_SplitTreeNode),
        .number = ITMListSessionsResponse_Tab_FieldNumber_Root,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_Tab__storage_, root),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMListSessionsResponse_Tab class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMListSessionsResponse_Tab__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMListSessionsResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMListSessionsResponse_SplitTreeNode

@implementation ITMListSessionsResponse_SplitTreeNode

@dynamic hasVertical, vertical;
@dynamic linksArray, linksArray_Count;

typedef struct ITMListSessionsResponse_SplitTreeNode__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *linksArray;
} ITMListSessionsResponse_SplitTreeNode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "vertical",
        .dataTypeSpecific.className = NULL,
        .number = ITMListSessionsResponse_SplitTreeNode_FieldNumber_Vertical,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "linksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListSessionsResponse_SplitTreeNode_SplitTreeLink),
        .number = ITMListSessionsResponse_SplitTreeNode_FieldNumber_LinksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_SplitTreeNode__storage_, linksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMListSessionsResponse_SplitTreeNode class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMListSessionsResponse_SplitTreeNode__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMListSessionsResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMListSessionsResponse_SplitTreeNode_SplitTreeLink

@implementation ITMListSessionsResponse_SplitTreeNode_SplitTreeLink

@dynamic childOneOfCase;
@dynamic session;
@dynamic node;

typedef struct ITMListSessionsResponse_SplitTreeNode_SplitTreeLink__storage_ {
  uint32_t _has_storage_[2];
  ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_Session *session;
  ITMListSessionsResponse_SplitTreeNode *node;
} ITMListSessionsResponse_SplitTreeNode_SplitTreeLink__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_Session),
        .number = ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_FieldNumber_Session,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_SplitTreeNode_SplitTreeLink__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "node",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListSessionsResponse_SplitTreeNode),
        .number = ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_FieldNumber_Node,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_SplitTreeNode_SplitTreeLink__storage_, node),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMListSessionsResponse_SplitTreeNode_SplitTreeLink class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMListSessionsResponse_SplitTreeNode_SplitTreeLink__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "child",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMListSessionsResponse_SplitTreeNode)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_ClearChildOneOfCase(ITMListSessionsResponse_SplitTreeNode_SplitTreeLink *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_Session

@implementation ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_Session

@dynamic hasUniqueIdentifier, uniqueIdentifier;
@dynamic hasFrame, frame;
@dynamic hasGridSize, gridSize;
@dynamic hasTitle, title;

typedef struct ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_Session__storage_ {
  uint32_t _has_storage_[1];
  NSString *uniqueIdentifier;
  ITMFrame *frame;
  ITMSize *gridSize;
  NSString *title;
} ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_Session__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uniqueIdentifier",
        .dataTypeSpecific.className = NULL,
        .number = ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_Session_FieldNumber_UniqueIdentifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_Session__storage_, uniqueIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "frame",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMFrame),
        .number = ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_Session_FieldNumber_Frame,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_Session__storage_, frame),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gridSize",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSize),
        .number = ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_Session_FieldNumber_GridSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_Session__storage_, gridSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_Session_FieldNumber_Title,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_Session__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_Session class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMListSessionsResponse_SplitTreeNode_SplitTreeLink_Session__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMListSessionsResponse_SplitTreeNode_SplitTreeLink)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMCreateTabRequest

@implementation ITMCreateTabRequest

@dynamic hasProfileName, profileName;
@dynamic hasWindowId, windowId;
@dynamic hasTabIndex, tabIndex;
@dynamic hasCommand, command;

typedef struct ITMCreateTabRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t tabIndex;
  NSString *profileName;
  NSString *windowId;
  NSString *command;
} ITMCreateTabRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "profileName",
        .dataTypeSpecific.className = NULL,
        .number = ITMCreateTabRequest_FieldNumber_ProfileName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMCreateTabRequest__storage_, profileName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMCreateTabRequest_FieldNumber_WindowId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMCreateTabRequest__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tabIndex",
        .dataTypeSpecific.className = NULL,
        .number = ITMCreateTabRequest_FieldNumber_TabIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMCreateTabRequest__storage_, tabIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "command",
        .dataTypeSpecific.className = NULL,
        .number = ITMCreateTabRequest_FieldNumber_Command,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMCreateTabRequest__storage_, command),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMCreateTabRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMCreateTabRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMCreateTabResponse

@implementation ITMCreateTabResponse

@dynamic hasStatus, status;
@dynamic hasWindowId, windowId;
@dynamic hasTabId, tabId;
@dynamic hasSessionId, sessionId;

typedef struct ITMCreateTabResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMCreateTabResponse_Status status;
  int32_t tabId;
  NSString *windowId;
  NSString *sessionId;
} ITMCreateTabResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMCreateTabResponse_Status_EnumDescriptor,
        .number = ITMCreateTabResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMCreateTabResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMCreateTabResponse_FieldNumber_WindowId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMCreateTabResponse__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tabId",
        .dataTypeSpecific.className = NULL,
        .number = ITMCreateTabResponse_FieldNumber_TabId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMCreateTabResponse__storage_, tabId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = ITMCreateTabResponse_FieldNumber_SessionId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMCreateTabResponse__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMCreateTabResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMCreateTabResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMCreateTabResponse_Status

GPBEnumDescriptor *ITMCreateTabResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000InvalidProfileName\000InvalidWindowId\000In"
        "validTabIndex\000MissingSubstitution\000";
    static const int32_t values[] = {
        ITMCreateTabResponse_Status_Ok,
        ITMCreateTabResponse_Status_InvalidProfileName,
        ITMCreateTabResponse_Status_InvalidWindowId,
        ITMCreateTabResponse_Status_InvalidTabIndex,
        ITMCreateTabResponse_Status_MissingSubstitution,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMCreateTabResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMCreateTabResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMCreateTabResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMCreateTabResponse_Status_Ok:
    case ITMCreateTabResponse_Status_InvalidProfileName:
    case ITMCreateTabResponse_Status_InvalidWindowId:
    case ITMCreateTabResponse_Status_InvalidTabIndex:
    case ITMCreateTabResponse_Status_MissingSubstitution:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMSplitPaneRequest

@implementation ITMSplitPaneRequest

@dynamic hasSession, session;
@dynamic hasSplitDirection, splitDirection;
@dynamic hasBefore, before;
@dynamic hasProfileName, profileName;

typedef struct ITMSplitPaneRequest__storage_ {
  uint32_t _has_storage_[1];
  ITMSplitPaneRequest_SplitDirection splitDirection;
  NSString *session;
  NSString *profileName;
} ITMSplitPaneRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMSplitPaneRequest_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSplitPaneRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "splitDirection",
        .dataTypeSpecific.enumDescFunc = ITMSplitPaneRequest_SplitDirection_EnumDescriptor,
        .number = ITMSplitPaneRequest_FieldNumber_SplitDirection,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMSplitPaneRequest__storage_, splitDirection),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "before",
        .dataTypeSpecific.className = NULL,
        .number = ITMSplitPaneRequest_FieldNumber_Before,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "profileName",
        .dataTypeSpecific.className = NULL,
        .number = ITMSplitPaneRequest_FieldNumber_ProfileName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ITMSplitPaneRequest__storage_, profileName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSplitPaneRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSplitPaneRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMSplitPaneRequest_SplitDirection

GPBEnumDescriptor *ITMSplitPaneRequest_SplitDirection_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Vertical\000Horizontal\000";
    static const int32_t values[] = {
        ITMSplitPaneRequest_SplitDirection_Vertical,
        ITMSplitPaneRequest_SplitDirection_Horizontal,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMSplitPaneRequest_SplitDirection)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMSplitPaneRequest_SplitDirection_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMSplitPaneRequest_SplitDirection_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMSplitPaneRequest_SplitDirection_Vertical:
    case ITMSplitPaneRequest_SplitDirection_Horizontal:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMSplitPaneResponse

@implementation ITMSplitPaneResponse

@dynamic hasStatus, status;
@dynamic sessionIdArray, sessionIdArray_Count;

typedef struct ITMSplitPaneResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMSplitPaneResponse_Status status;
  NSMutableArray *sessionIdArray;
} ITMSplitPaneResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMSplitPaneResponse_Status_EnumDescriptor,
        .number = ITMSplitPaneResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSplitPaneResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sessionIdArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMSplitPaneResponse_FieldNumber_SessionIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMSplitPaneResponse__storage_, sessionIdArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSplitPaneResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSplitPaneResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMSplitPaneResponse_Status

GPBEnumDescriptor *ITMSplitPaneResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000InvalidProfileName\000Ca"
        "nnotSplit\000";
    static const int32_t values[] = {
        ITMSplitPaneResponse_Status_Ok,
        ITMSplitPaneResponse_Status_SessionNotFound,
        ITMSplitPaneResponse_Status_InvalidProfileName,
        ITMSplitPaneResponse_Status_CannotSplit,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMSplitPaneResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMSplitPaneResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMSplitPaneResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMSplitPaneResponse_Status_Ok:
    case ITMSplitPaneResponse_Status_SessionNotFound:
    case ITMSplitPaneResponse_Status_InvalidProfileName:
    case ITMSplitPaneResponse_Status_CannotSplit:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
